from itertools import permutations

import networkx as nx
from rdkit import Chem
from rdkit.Chem import rdChemReactions

from lib._mapping import process_reactants, atom_map, bond_map
from lib.utils import reaction_mol_mapping


class Reaction(object):
    def __init__(self, name, cg_reactant_list, smarts, prod_idx=None):
        self.cg_reactant_list = cg_reactant_list
        self.reaction_name = name
        self.reaction = rdChemReactions.ReactionFromSmarts(smarts)
        self.smarts = smarts
        self.prod_idx = prod_idx
        self.reaction_maps = {}

    def build_reaction_maps(self, cg_reactants, molecules):
        if self.reaction_maps.get(cg_reactants) is None:
            self.reaction_maps[cg_reactants] = []
            reactants = process_reactants(molecules)
            products = self.reaction.RunReactants(reactants)
            if len(products) == 0:
                raise ValueError(f"Reaction {self.smarts} does not run on CG reactants {cg_reactants}")
            for product in products:
                amap, reacting_atoms = atom_map(product, self.reaction)
                bmap = bond_map(reactants, product, self.reaction)
                self.reaction_maps[cg_reactants].append((reacting_atoms, amap, bmap))


def allowed_p(reacted_atoms, cg_reactants, reaction):
    for reaction_map in reaction.reaction_maps.get(cg_reactants):
        # iterate over all possible permutations generated by rxn.RunReactants
        # choose the proper candidate with all functional groups are idle.
        allowed = True
        for ri in reaction_map[0]:
            if set.intersection(set(reaction_map[0][ri]), reacted_atoms[ri]):
                # not necessarily subset, e.g.,
                # reaction 1 takes {0,1},{10,11} but reaction 2 takes {0,1,2,3}, {10,11,12,13}
                # if reaction 1 happened with {0,1} already, reacted atoms has intersection with
                # reaction 2
                # if set.issubset(set(reaction_map[0][ri]), reacted_atoms[ri]):  # only idle function groups
                # multi-step reaction_info are considered as reaction_info with all reactants in one step.
                # FOR ANY ATOM, THERE IS ONLY ONE REACTION, therefore intersection is fine.
                allowed = False
        if allowed:
            return reaction_map, reaction.prod_idx
    return None, None  # if no available reaction is chosen.


class Reactor(object):
    def __init__(self, reactants_meta, reaction_templates):
        r"""Reactor object, generate method first, then process the system.
        :param reactants_meta: dict {type: {smiles: ''}
        :param reaction_templates: dict: {'reaction_name':
        {cg_reactant_list: [(A,B), ...], smarts: <smarts>, prod_idx: [0,1,..]}}
        """
        self.reactants_meta = reactants_meta
        self.cg_molecules = None
        self.aa_molecules = []
        self.meta = []
        self.reaction_templates = {}
        for reaction_name in reaction_templates:
            _info = reaction_templates[reaction_name]
            self.reaction_templates[reaction_name] = Reaction(
                reaction_name, _info['cg_reactant_list'], _info['smarts'], _info.get("prod_idx")
            )

    def process(self, cg_molecules, reactions):
        r"""Process a specific cg system.
        :param cg_molecules: list of molecules: [nx.Graph(global_molecule_id, smiles=smiles),...]
        :param reactions: list of reaction_info, [(reaction_name, i, j, k,...),]
        :return: aa_system and meta info
        """
        self.cg_molecules = cg_molecules
        reaction_hash = reaction_mol_mapping(reactions)  # build reaction hash: {node: set(reactions1,...)}
        for _i, cg_mol in enumerate(cg_molecules):
            # generate per cg mol, for removing atom is slow for large molecules
            # print(len(cg_mol.nodes), _i, len(cg_molecules))
            aa_mol = Chem.RWMol()
            mol_meta = nx.Graph()
            global_count = 0
            mol_reactions = set()
            for node in cg_mol.nodes:
                atom_idx = {}  # global-local index hash
                for r in reaction_hash[node]:
                    # get reactions for mol, reaction_hash = {node: set of reactions contain the node}
                    # attach reaction to mol if any of the monomers in the mol is involved in the reaction
                    mol_reactions.add(r)
                reactant = cg_mol.nodes[node]
                reactant_molecule = Chem.MolFromSmiles(reactant['smiles'])
                for atom_id in range(reactant_molecule.GetNumAtoms()):
                    atom = reactant_molecule.GetAtomWithIdx(atom_id)
                    aa_mol.AddAtom(atom)
                    atom_idx[atom_id] = atom_id + global_count
                for bond in reactant_molecule.GetBonds():
                    aa_mol.AddBond(
                        bond.GetBeginAtomIdx() + global_count,
                        bond.GetEndAtomIdx() + global_count,
                        bond.GetBondType()
                    )
                global_count += reactant_molecule.GetNumAtoms()
                mol_meta.add_node(node, atom_idx=atom_idx, reacting_map={}, rm_atoms=set())
                # add all atoms first, add new bonds, change/delete bonds according to reaction
                # then remove atoms of side products
            for edge in cg_mol.edges:
                mol_meta.add_edge(*edge)
            for r in mol_reactions:
                reaction_name = r[0]
                _reactant_idx = r[1:]
                rxn_tpls = self.reaction_templates.get(reaction_name)
                if rxn_tpls is None:
                    raise ValueError(f"Reaction {r} is not defined in reaction_info!")

                _all_orders = list(permutations(_reactant_idx))
                _reactants_tuple = tuple([cg_mol.nodes[_]['type'] for _ in _reactant_idx])
                reactants_order = reactants_tuple = None
                for _order in _all_orders:
                    _tuple = tuple([cg_mol.nodes[_]['type'] for _ in _order])
                    if _tuple in rxn_tpls.cg_reactant_list:
                        reactants_order = _order
                        reactants_tuple = _tuple  # correct order
                if not reactants_order:
                    raise ValueError(f"Reaction {r} for reactants ({_reactants_tuple}) is not defined!")

                _molecules = []
                for t in reactants_tuple:
                    _molecules.append(Chem.MolFromSmiles(self.reactants_meta[t]['smiles']))
                rxn_tpls.build_reaction_maps(reactants_tuple, _molecules)  # make reaction maps on-the-fly

                reactants = [mol_meta.nodes[_] for _ in reactants_order]  # this is META info for reactants
                key = tuple(sorted(_reactant_idx))  # dict key for storing reacted atoms
                reacted_atoms = {}

                for ri in range(len(reactants)):
                    reacted_atoms[ri] = set()

                for ri, rt in enumerate(reactants):  # keep reactant order
                    for k in rt['reacting_map']:
                        for at in rt['reacting_map'][k]:
                            reacted_atoms[ri].add(at)

                reaction_map, product_idx = allowed_p(reacted_atoms, reactants_tuple, rxn_tpls)
                # finding allowed reaction maps
                # process reaction case by case
                # get available reaction from all possible
                # permutations generated by rxn.RunReactants
                if not reaction_map:
                    raise (ValueError(f"{r} with order {_reactant_idx}, {_reactants_tuple} can not react!"))

                amap, bmap = reaction_map[1], reaction_map[2]  # store the reacted atoms.
                for ri, rt in enumerate(reactants):
                    if rt['reacting_map'].get(key) is None:
                        rt['reacting_map'][key] = set()
                    for at in reaction_map[0][ri]:
                        rt['reacting_map'][key].add(at)

                for atom in amap:  # remove / change / add bonds first, remove atoms from side productions then
                    if product_idx is not None:
                        if atom.product_id not in product_idx:
                            reactant = reactants[atom.reactant_id]
                            reactant['rm_atoms'].add(reactant['atom_idx'][atom.reactant_atom_id])
                for b in bmap:
                    if b.status == 'deleted':
                        reactant = reactants[b.reactants_id[0]]
                        bi = reactant['atom_idx'][b.reactant_atoms_id[0]]
                        bj = reactant['atom_idx'][b.reactant_atoms_id[1]]
                        aa_mol.RemoveBond(bi, bj)
                    if b.status == 'changed':
                        reactant = reactants[b.reactants_id[0]]  # bond changed, in same reactant
                        bi = reactant['atom_idx'][b.reactant_atoms_id[0]]
                        bj = reactant['atom_idx'][b.reactant_atoms_id[1]]
                        bond = aa_mol.GetBondBetweenAtoms(bi, bj)
                        bond.SetBondType(b.bond_type)
                    if b.status == 'new':
                        reactant0 = reactants[b.reactants_id[0]]
                        reactant1 = reactants[b.reactants_id[1]]
                        bi = reactant0['atom_idx'][b.reactant_atoms_id[0]]
                        bj = reactant1['atom_idx'][b.reactant_atoms_id[1]]
                        aa_mol.AddBond(bi, bj, b.bond_type)

            rm_all = []
            for m in mol_meta.nodes:  # remove atoms in side productions
                molecule = mol_meta.nodes[m]
                for idx in molecule['atom_idx'].values():
                    atom = aa_mol.GetAtomWithIdx(idx)
                    atom.SetIntProp('molecule_id', int(m))
                rm_all.extend(list(molecule['rm_atoms']))

            rm_all = sorted(list(set(rm_all)), reverse=True)
            for bi in rm_all:
                aa_mol.RemoveAtom(bi)
            # print(Chem.MolToSmiles(aa_mol))
            # Chem.SanitizeMol(aa_mol)
            self.aa_molecules.append(Chem.RemoveAllHs(aa_mol))
            self.meta.append(mol_meta)
